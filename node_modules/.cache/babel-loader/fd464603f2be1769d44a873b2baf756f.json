{"ast":null,"code":"import invariant from '../utils/invariant';\nimport shallowEqual from '../utils/shallowEqual';\nconst SCENE_KEY_PREFIX = 'scene_';\n/**\n * Helper function to compare route keys (e.g. \"9\", \"11\").\n */\n\nfunction compareKey(one, two) {\n  const delta = one.length - two.length;\n\n  if (delta > 0) {\n    return 1;\n  }\n\n  if (delta < 0) {\n    return -1;\n  }\n\n  return one > two ? 1 : -1;\n}\n/**\n * Helper function to sort scenes based on their index and view key.\n */\n\n\nfunction compareScenes(one, two) {\n  if (one.index > two.index) {\n    return 1;\n  }\n\n  if (one.index < two.index) {\n    return -1;\n  }\n\n  return compareKey(one.key, two.key);\n}\n/**\n * Whether two routes are the same.\n */\n\n\nfunction areScenesShallowEqual(one, two) {\n  return one.key === two.key && one.index === two.index && one.isStale === two.isStale && one.isActive === two.isActive && areRoutesShallowEqual(one.route, two.route);\n}\n/**\n * Whether two routes are the same.\n */\n\n\nfunction areRoutesShallowEqual(one, two) {\n  if (!one || !two) {\n    return one === two;\n  }\n\n  if (one.key !== two.key) {\n    return false;\n  }\n\n  return shallowEqual(one, two);\n}\n\nexport default function ScenesReducer(scenes, nextState, prevState, descriptors) {\n  // Always update the descriptors\n  // This is a workaround for https://github.com/react-navigation/react-navigation/issues/4271\n  // It will be resolved in a better way when we re-write Transitioner\n  scenes.forEach(scene => {\n    const route = scene.route;\n\n    if (descriptors && descriptors[route.key]) {\n      scene.descriptor = descriptors[route.key];\n    }\n  }); // Bail out early if we didn't update the state\n\n  if (prevState === nextState) {\n    return scenes;\n  }\n\n  const prevScenes = new Map();\n  const freshScenes = new Map();\n  const staleScenes = new Map(); // Populate stale scenes from previous scenes marked as stale.\n\n  scenes.forEach(scene => {\n    const key = scene.key;\n\n    if (scene.isStale) {\n      staleScenes.set(key, scene);\n    }\n\n    prevScenes.set(key, scene);\n  });\n  const nextKeys = new Set();\n  let nextRoutes = nextState.routes;\n\n  if (nextRoutes.length > nextState.index + 1) {\n    console.warn('StackRouter provided invalid state, index should always be the top route');\n    nextRoutes = nextState.routes.slice(0, nextState.index + 1);\n  }\n\n  nextRoutes.forEach((route, index) => {\n    const key = SCENE_KEY_PREFIX + route.key;\n    let descriptor = descriptors && descriptors[route.key];\n    const scene = {\n      index,\n      isActive: false,\n      isStale: false,\n      key,\n      route,\n      descriptor\n    };\n    invariant(!nextKeys.has(key), \"navigation.state.routes[\".concat(index, \"].key \\\"\").concat(key, \"\\\" conflicts with \") + 'another route!');\n    nextKeys.add(key);\n\n    if (staleScenes.has(key)) {\n      // A previously `stale` scene is now part of the nextState, so we\n      // revive it by removing it from the stale scene map.\n      staleScenes.delete(key);\n    }\n\n    freshScenes.set(key, scene);\n  });\n\n  if (prevState) {\n    let prevRoutes = prevState.routes;\n\n    if (prevRoutes.length > prevState.index + 1) {\n      console.warn('StackRouter provided invalid state, index should always be the top route');\n      prevRoutes = prevRoutes.slice(0, prevState.index + 1);\n    } // Look at the previous routes and classify any removed scenes as `stale`.\n\n\n    prevRoutes.forEach((route, index) => {\n      const key = SCENE_KEY_PREFIX + route.key;\n\n      if (freshScenes.has(key)) {\n        return;\n      }\n\n      const lastScene = scenes.find(scene => scene.route.key === route.key); // We can get into a weird place where we have a queued transition and then clobber\n      // that transition without ever actually rendering the scene, in which case\n      // there is no lastScene. If the descriptor is not available on the lastScene\n      // or the descriptors prop then we just skip adding it to stale scenes and it's\n      // not ever rendered.\n\n      const descriptor = lastScene ? lastScene.descriptor : descriptors[route.key];\n\n      if (descriptor) {\n        staleScenes.set(key, {\n          index,\n          isActive: false,\n          isStale: true,\n          key,\n          route,\n          descriptor\n        });\n      }\n    });\n  }\n\n  const nextScenes = [];\n\n  const mergeScene = nextScene => {\n    const key = nextScene.key;\n    const prevScene = prevScenes.has(key) ? prevScenes.get(key) : null;\n\n    if (prevScene && areScenesShallowEqual(prevScene, nextScene)) {\n      // Reuse `prevScene` as `scene` so view can avoid unnecessary re-render.\n      // This assumes that the scene's navigation state is immutable.\n      nextScenes.push(prevScene);\n    } else {\n      nextScenes.push(nextScene);\n    }\n  };\n\n  staleScenes.forEach(mergeScene);\n  freshScenes.forEach(mergeScene);\n  nextScenes.sort(compareScenes);\n  let activeScenesCount = 0;\n  nextScenes.forEach((scene, ii) => {\n    const isActive = !scene.isStale && scene.index === nextState.index;\n\n    if (isActive !== scene.isActive) {\n      nextScenes[ii] = { ...scene,\n        isActive\n      };\n    }\n\n    if (isActive) {\n      activeScenesCount++;\n    }\n  });\n  invariant(activeScenesCount === 1, 'there should always be only one scene active, not %s.', activeScenesCount);\n\n  if (nextScenes.length !== scenes.length) {\n    return nextScenes;\n  }\n\n  if (nextScenes.some((scene, index) => !areScenesShallowEqual(scenes[index], scene))) {\n    return nextScenes;\n  } // scenes haven't changed.\n\n\n  return scenes;\n}","map":null,"metadata":{},"sourceType":"module"}