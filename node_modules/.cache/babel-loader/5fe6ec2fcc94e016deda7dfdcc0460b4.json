{"ast":null,"code":"import { I18nManager } from 'react-native';\nimport getSceneIndicesForInterpolationInputRange from '../../utils/getSceneIndicesForInterpolationInputRange';\nconst EPS = 1e-5;\n/**\n * Utility that builds the style for the card in the cards stack.\n *\n *     +------------+\n *   +-+            |\n * +-+ |            |\n * | | |            |\n * | | |  Focused   |\n * | | |   Card     |\n * | | |            |\n * +-+ |            |\n *   +-+            |\n *     +------------+\n */\n\n/**\n * Render the initial style when the initial layout isn't measured yet.\n */\n\nfunction forInitial(props) {\n  const navigation = props.navigation,\n        scene = props.scene;\n  const focused = navigation.state.index === scene.index;\n  const opacity = focused ? 1 : 0; // If not focused, move the scene far away.\n\n  const translate = focused ? 0 : 1000000;\n  return {\n    opacity,\n    transform: [{\n      translateX: translate\n    }, {\n      translateY: translate\n    }]\n  };\n}\n/**\n * Standard iOS-style slide in from the right.\n */\n\n\nfunction forHorizontal(props) {\n  const layout = props.layout,\n        position = props.position,\n        scene = props.scene;\n\n  if (!layout.isMeasured) {\n    return forInitial(props);\n  }\n\n  const interpolate = getSceneIndicesForInterpolationInputRange(props);\n  if (!interpolate) return {\n    opacity: 0\n  };\n  const first = interpolate.first,\n        last = interpolate.last;\n  const index = scene.index;\n  const width = layout.initWidth;\n  const translateX = position.interpolate({\n    inputRange: [first, index, last],\n    outputRange: I18nManager.isRTL ? [-width, 0, width * 0.3] : [width, 0, width * -0.3],\n    extrapolate: 'clamp'\n  });\n  const shadowOpacity = props.shadowEnabled ? position.interpolate({\n    inputRange: [first, index, last],\n    outputRange: [0, 0.7, 0],\n    extrapolate: 'clamp'\n  }) : null;\n  let overlayOpacity = props.cardOverlayEnabled ? position.interpolate({\n    inputRange: [index, last - 0.5, last, last + EPS],\n    outputRange: [0, 0.07, 0.07, 0],\n    extrapolate: 'clamp'\n  }) : null;\n  return {\n    transform: [{\n      translateX\n    }],\n    overlayOpacity,\n    shadowOpacity\n  };\n}\n/**\n * Standard iOS-style slide in from the bottom (used for modals).\n */\n\n\nfunction forVertical(props) {\n  const layout = props.layout,\n        position = props.position,\n        scene = props.scene;\n\n  if (!layout.isMeasured) {\n    return forInitial(props);\n  }\n\n  const interpolate = getSceneIndicesForInterpolationInputRange(props);\n  if (!interpolate) return {\n    opacity: 0\n  };\n  const first = interpolate.first,\n        last = interpolate.last;\n  const index = scene.index;\n  const height = layout.initHeight;\n  const translateY = position.interpolate({\n    inputRange: [first, index, last],\n    outputRange: [height, 0, 0],\n    extrapolate: 'clamp'\n  });\n  return {\n    transform: [{\n      translateY\n    }]\n  };\n}\n/**\n * Standard Android-style fade in from the bottom.\n */\n\n\nfunction forFadeFromBottomAndroid(props) {\n  const layout = props.layout,\n        position = props.position,\n        scene = props.scene;\n\n  if (!layout.isMeasured) {\n    return forInitial(props);\n  }\n\n  const interpolate = getSceneIndicesForInterpolationInputRange(props);\n  if (!interpolate) return {\n    opacity: 0\n  };\n  const first = interpolate.first,\n        last = interpolate.last;\n  const index = scene.index;\n  const opacity = position.interpolate({\n    inputRange: [first, first + 0.5, first + 0.9, index, last - 1e-5, last],\n    outputRange: [0, 0.25, 0.7, 1, 1, 0],\n    extrapolate: 'clamp'\n  });\n  const height = layout.initHeight;\n  const maxTranslation = height * 0.08;\n  const translateY = position.interpolate({\n    inputRange: [first, index, last],\n    outputRange: [maxTranslation, 0, 0],\n    extrapolate: 'clamp'\n  });\n  return {\n    opacity,\n    transform: [{\n      translateY\n    }]\n  };\n}\n\nfunction forFadeToBottomAndroid(props) {\n  const layout = props.layout,\n        position = props.position,\n        scene = props.scene;\n\n  if (!layout.isMeasured) {\n    return forInitial(props);\n  }\n\n  const interpolate = getSceneIndicesForInterpolationInputRange(props);\n  if (!interpolate) return {\n    opacity: 0\n  };\n  const first = interpolate.first,\n        last = interpolate.last;\n  const index = scene.index;\n  const inputRange = [first, index, last];\n  const opacity = position.interpolate({\n    inputRange,\n    outputRange: [0, 1, 1],\n    extrapolate: 'clamp'\n  });\n  const height = layout.initHeight;\n  const maxTranslation = height * 0.08;\n  const translateY = position.interpolate({\n    inputRange,\n    outputRange: [maxTranslation, 0, 0],\n    extrapolate: 'clamp'\n  });\n  return {\n    opacity,\n    transform: [{\n      translateY\n    }]\n  };\n}\n/**\n *  fadeIn and fadeOut\n */\n\n\nfunction forFade(props) {\n  const layout = props.layout,\n        position = props.position,\n        scene = props.scene;\n\n  if (!layout.isMeasured) {\n    return forInitial(props);\n  }\n\n  const interpolate = getSceneIndicesForInterpolationInputRange(props);\n  if (!interpolate) return {\n    opacity: 0\n  };\n  const first = interpolate.first,\n        last = interpolate.last;\n  const index = scene.index;\n  const opacity = position.interpolate({\n    inputRange: [first, index, last],\n    outputRange: [0, 1, 1],\n    extrapolate: 'clamp'\n  });\n  return {\n    opacity\n  };\n}\n\nfunction forNoAnimation() {\n  return {};\n}\n\nexport default {\n  forHorizontal,\n  forVertical,\n  forFadeFromBottomAndroid,\n  forFadeToBottomAndroid,\n  forFade,\n  forNoAnimation\n};","map":null,"metadata":{},"sourceType":"module"}