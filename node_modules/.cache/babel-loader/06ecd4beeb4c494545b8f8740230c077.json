{"ast":null,"code":"import { Dimensions, I18nManager } from 'react-native';\nimport getSceneIndicesForInterpolationInputRange from '../../utils/getSceneIndicesForInterpolationInputRange';\n\nfunction hasHeader(scene) {\n  if (!scene) {\n    return true;\n  }\n\n  const descriptor = scene.descriptor;\n  return descriptor.options.header !== null;\n}\n\nconst crossFadeInterpolation = (scenes, first, index, last) => ({\n  inputRange: [first, first + 0.001, index - 0.9, index - 0.2, index, last - 0.001, last],\n  outputRange: [0, hasHeader(scenes[first]) ? 0 : 1, hasHeader(scenes[first]) ? 0 : 1, hasHeader(scenes[first]) ? 0.3 : 1, hasHeader(scenes[index]) ? 1 : 0, hasHeader(scenes[last]) ? 0 : 1, 0],\n  extrapolate: 'clamp'\n});\n/**\n * Utilities that build the style for the navigation header.\n *\n * +-------------+-------------+-------------+\n * |             |             |             |\n * |    Left     |   Title     |   Right     |\n * |  Component  |  Component  | Component   |\n * |             |             |             |\n * +-------------+-------------+-------------+\n */\n\n\nfunction isGoingBack(scenes) {\n  const lastSceneIndexInScenes = scenes.length - 1;\n  return !scenes[lastSceneIndexInScenes].isActive;\n}\n\nfunction forLayout(props) {\n  const layout = props.layout,\n        position = props.position,\n        scene = props.scene,\n        scenes = props.scenes,\n        mode = props.mode;\n\n  if (mode !== 'float') {\n    return {};\n  }\n\n  const isBack = isGoingBack(scenes);\n  const interpolate = getSceneIndicesForInterpolationInputRange(props);\n  if (!interpolate) return {};\n  const first = interpolate.first,\n        last = interpolate.last;\n  const index = scene.index; // We really shouldn't render the scene at all until we know the width of the\n  // stack. That said, in every case that I have ever seen, this has just been\n  // the full width of the window. This won't continue to be true if we support\n  // layouts like iPad master-detail. For now, in order to solve\n  // https://github.com/react-navigation/react-navigation/issues/4264, I have\n  // opted for the heuristic that we will use the window width until we have\n  // measured (and they will usually be the same).\n\n  const width = layout.initWidth || Dimensions.get('window').width; // Make sure the header stays hidden when transitioning between 2 screens\n  // with no header.\n\n  if (isBack && !hasHeader(scenes[index]) && !hasHeader(scenes[last]) || !isBack && !hasHeader(scenes[first]) && !hasHeader(scenes[index])) {\n    return {\n      transform: [{\n        translateX: width\n      }]\n    };\n  }\n\n  const rtlMult = I18nManager.isRTL ? -1 : 1;\n  const translateX = position.interpolate({\n    inputRange: [first, index, last],\n    outputRange: [rtlMult * (hasHeader(scenes[first]) ? 0 : width), rtlMult * (hasHeader(scenes[index]) ? 0 : isBack ? width : -width), rtlMult * (hasHeader(scenes[last]) ? 0 : -width)],\n    extrapolate: 'clamp'\n  });\n  return {\n    transform: [{\n      translateX\n    }]\n  };\n}\n\nfunction forLeft(props) {\n  const position = props.position,\n        scene = props.scene,\n        scenes = props.scenes;\n  const interpolate = getSceneIndicesForInterpolationInputRange(props);\n  if (!interpolate) return {\n    opacity: 0\n  };\n  const first = interpolate.first,\n        last = interpolate.last;\n  const index = scene.index;\n  return {\n    opacity: position.interpolate(crossFadeInterpolation(scenes, first, index, last))\n  };\n}\n\nfunction forCenter(props) {\n  const position = props.position,\n        scene = props.scene,\n        scenes = props.scenes;\n  const interpolate = getSceneIndicesForInterpolationInputRange(props);\n  if (!interpolate) return {\n    opacity: 0\n  };\n  const first = interpolate.first,\n        last = interpolate.last;\n  const index = scene.index;\n  return {\n    opacity: position.interpolate(crossFadeInterpolation(scenes, first, index, last))\n  };\n}\n\nfunction forRight(props) {\n  const position = props.position,\n        scene = props.scene,\n        scenes = props.scenes;\n  const interpolate = getSceneIndicesForInterpolationInputRange(props);\n  if (!interpolate) return {\n    opacity: 0\n  };\n  const first = interpolate.first,\n        last = interpolate.last;\n  const index = scene.index;\n  return {\n    opacity: position.interpolate(crossFadeInterpolation(scenes, first, index, last))\n  };\n}\n/**\n * iOS UINavigationController style interpolators\n */\n\n\nfunction forLeftButton(props) {\n  const position = props.position,\n        scene = props.scene,\n        scenes = props.scenes;\n  const interpolate = getSceneIndicesForInterpolationInputRange(props);\n  if (!interpolate) return {\n    opacity: 0\n  };\n  const first = interpolate.first,\n        last = interpolate.last;\n  const index = scene.index; // The gist of what we're doing here is animating the left button _normally_ (fast fade)\n  // when both scenes in transition have headers. When the current, next, or previous scene _don't_\n  // have a header, we don't fade the button, and only set it's opacity to 0 at the last moment\n  // of the transition.\n\n  const inputRange = [first, first + 0.001, first + Math.abs(index - first) / 2, index, last - Math.abs(last - index) / 2, last - 0.001, last];\n  const outputRange = [0, hasHeader(scenes[first]) ? 0 : 1, hasHeader(scenes[first]) ? 0.3 : 1, hasHeader(scenes[index]) ? 1 : 0, hasHeader(scenes[last]) ? 0.3 : 1, hasHeader(scenes[last]) ? 0 : 1, 0];\n  return {\n    opacity: position.interpolate({\n      inputRange,\n      outputRange,\n      extrapolate: 'clamp'\n    })\n  };\n}\n/*\n * NOTE: this offset calculation is an approximation that gives us\n * decent results in many cases, but it is ultimately a poor substitute\n * for text measurement. See the comment on title for more information.\n *\n * - 70 is the width of the left button area.\n * - 25 is the width of the left button icon (to account for label offset)\n */\n\n\nconst LEFT_LABEL_OFFSET = Dimensions.get('window').width / 2 - 70 - 25;\n\nfunction forLeftLabel(props) {\n  const position = props.position,\n        scene = props.scene,\n        scenes = props.scenes;\n  const interpolate = getSceneIndicesForInterpolationInputRange(props);\n  if (!interpolate) return {\n    opacity: 0\n  };\n  const first = interpolate.first,\n        last = interpolate.last;\n  const index = scene.index;\n  const offset = LEFT_LABEL_OFFSET; // Similarly to the animation of the left label, when animating to or from a scene without\n  // a header, we keep the label at full opacity and in the same position for as long as possible.\n\n  return {\n    // For now we fade out the label before fading in the title, so the\n    // differences between the label and title position can be hopefully not so\n    // noticable to the user\n    opacity: position.interpolate({\n      inputRange: [first, first + 0.001, index - 0.35, index, index + 0.5, last - 0.001, last],\n      outputRange: [0, hasHeader(scenes[first]) ? 0 : 1, hasHeader(scenes[first]) ? 0 : 1, hasHeader(scenes[index]) ? 1 : 0, hasHeader(scenes[last]) ? 0.5 : 1, hasHeader(scenes[last]) ? 0 : 1, 0],\n      extrapolate: 'clamp'\n    }),\n    transform: [{\n      translateX: position.interpolate({\n        inputRange: [first, first + 0.001, index, last - 0.001, last],\n        outputRange: I18nManager.isRTL ? [-offset * 1.5, hasHeader(scenes[first]) ? -offset * 1.5 : 0, 0, hasHeader(scenes[last]) ? offset : 0, offset] : [offset, hasHeader(scenes[first]) ? offset : 0, 0, hasHeader(scenes[last]) ? -offset * 1.5 : 0, -offset * 1.5],\n        extrapolate: 'clamp'\n      })\n    }]\n  };\n}\n/*\n * NOTE: this offset calculation is a an approximation that gives us\n * decent results in many cases, but it is ultimately a poor substitute\n * for text measurement. We want the back button label to transition\n * smoothly into the title text and to do this we need to understand\n * where the title is positioned within the title container (since it is\n * centered).\n *\n * - 70 is the width of the left button area.\n * - 25 is the width of the left button icon (to account for label offset)\n */\n\n\nconst TITLE_OFFSET_IOS = Dimensions.get('window').width / 2 - 70 + 25;\n\nfunction forCenterFromLeft(props) {\n  const position = props.position,\n        scene = props.scene,\n        scenes = props.scenes;\n  const interpolate = getSceneIndicesForInterpolationInputRange(props);\n  if (!interpolate) return {\n    opacity: 0\n  };\n  const first = interpolate.first,\n        last = interpolate.last;\n  const index = scene.index;\n  const offset = TITLE_OFFSET_IOS;\n  return {\n    opacity: position.interpolate({\n      inputRange: [first, first + 0.001, index - 0.5, index, index + 0.7, last - 0.001, last],\n      outputRange: [0, hasHeader(scenes[first]) ? 0 : 1, hasHeader(scenes[first]) ? 0 : 1, hasHeader(scenes[index]) ? 1 : 0, hasHeader(scenes[last]) ? 0 : 1, hasHeader(scenes[last]) ? 0 : 1, 0],\n      extrapolate: 'clamp'\n    }),\n    transform: [{\n      translateX: position.interpolate({\n        inputRange: [first, first + 0.001, index, last - 0.001, last],\n        outputRange: I18nManager.isRTL ? [-offset, hasHeader(scenes[first]) ? -offset : 0, 0, hasHeader(scenes[last]) ? offset : 0, offset] : [offset, hasHeader(scenes[first]) ? offset : 0, 0, hasHeader(scenes[last]) ? -offset : 0, -offset],\n        extrapolate: 'clamp'\n      })\n    }]\n  };\n} // Fade in background of header while transitioning\n\n\nfunction forBackgroundWithFade(props) {\n  const position = props.position,\n        scene = props.scene;\n  const sceneRange = getSceneIndicesForInterpolationInputRange(props);\n  if (!sceneRange) return {\n    opacity: 0\n  };\n  return {\n    opacity: position.interpolate({\n      inputRange: [sceneRange.first, scene.index, sceneRange.last],\n      outputRange: [0, 1, 0],\n      extrapolate: 'clamp'\n    })\n  };\n}\n\nconst VISIBLE = {\n  opacity: 1\n};\nconst HIDDEN = {\n  opacity: 0\n}; // Toggle visibility of header without fading\n\nfunction forBackgroundWithInactiveHidden({\n  navigation,\n  scene\n}) {\n  return navigation.state.index === scene.index ? VISIBLE : HIDDEN;\n} // Translate the background with the card\n\n\nconst BACKGROUND_OFFSET = Dimensions.get('window').width;\n\nfunction forBackgroundWithTranslation(props) {\n  const position = props.position,\n        scene = props.scene;\n  const interpolate = getSceneIndicesForInterpolationInputRange(props);\n  if (!interpolate) return {\n    opacity: 0\n  };\n  const first = interpolate.first,\n        last = interpolate.last;\n  const index = scene.index;\n  const offset = BACKGROUND_OFFSET;\n  const outputRange = [offset, 0, -offset];\n  return {\n    transform: [{\n      translateX: position.interpolate({\n        inputRange: [first, index, last],\n        outputRange: I18nManager.isRTL ? outputRange.reverse() : outputRange,\n        extrapolate: 'clamp'\n      })\n    }]\n  };\n} // Default to fade transition\n\n\nconst forBackground = forBackgroundWithInactiveHidden;\nexport default {\n  forLayout,\n  forLeft,\n  forLeftButton,\n  forLeftLabel,\n  forCenterFromLeft,\n  forCenter,\n  forRight,\n  forBackground,\n  forBackgroundWithInactiveHidden,\n  forBackgroundWithFade,\n  forBackgroundWithTranslation\n};","map":null,"metadata":{},"sourceType":"module"}